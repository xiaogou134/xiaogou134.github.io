{"meta":{"title":"xiaogou134的博客","subtitle":"好饿啊","description":"学习博客","author":"xiaogou134","url":"http://www.xiaogou134.games"},"posts":[{"title":"Playables","slug":"Playables","date":"2023-04-18T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2023/04/18/Playables/","link":"","permalink":"http://www.xiaogou134.games/2023/04/18/Playables/","excerpt":"","text":"Playables Playables API通过在被称为PlayableGraph的树状结构中组织和评估数据源来创建工具、效果或其他游戏机制。PlayableGraph允许你混合、融合和修改多个数据源，并通过一个单一的输出来播放它们。数据源可以是动画、音频和脚本类型，Playables API还提供了通过脚本与动画系统和音频系统互动的能力。 Playables vs AnimationAnimation有一个图形编辑工具，这是一个状态机系统，只限于播放动画。但Playables API支持其他系统，允许创建状态机无法实现的图形。这些图表示数据流，表明每个节点产生和消耗的东西。此外，单个图形不限于单个系统。一个单一的图可以包含动画、音频和脚本的节点。![[Pasted image 20230331102208.png]]","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"Doing","slug":"Doing","permalink":"http://www.xiaogou134.games/tags/Doing/"}]},{"title":"2D Sprite Shape","slug":"2D Sprite Shape","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.507Z","comments":true,"path":"2023/04/17/2D Sprite Shape/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/2D%20Sprite%20Shape/","excerpt":"","text":"2D Sprite Shape","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"ToDo","slug":"ToDo","permalink":"http://www.xiaogou134.games/tags/ToDo/"}]},{"title":"Albedo","slug":"Albedo","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.507Z","comments":true,"path":"2023/04/17/Albedo/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/Albedo/","excerpt":"","text":"Albedo Color and Transparency","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"ToDo","slug":"ToDo","permalink":"http://www.xiaogou134.games/tags/ToDo/"}]},{"title":"Asset Bundles","slug":"Asset Bundle","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.507Z","comments":true,"path":"2023/04/17/Asset Bundle/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/Asset%20Bundle/","excerpt":"","text":"Asset Bundles 1234567891011121314151617181920212223242526272829303132333435```***## 工作流### AssetBundle里有什么？- 序列化文件：包含你的资产（应该是ScriptableObject的代码），这些资产被分解成各自的对象并被写入这个单一的文件。- 资源文件：保存了二进制数据（纹理和音效），允许Unity从另一个线程有效的加载资产。### 指定AssetBundle（AB包）资产的步骤指定AB包资产的步骤如下。 1. 从你的项目视图中选择你想分配给一个AB包的资产。 2. 在`Inspector`中检查该对象 。3. 在`Inspector`的底部，有两个下拉菜单用于分配AB包（左）和`Variants`（右）。4. 当前左侧下拉菜单显示为 `None`，这里表示资产没有分配AB包。点击`New`来创建一个新的`AB包`。 6. 输入AB包名称。（AB包名称支持文件夹结构，使用`environment/forest`可以在在`environment`子文件夹下创建一个名为`forest`的包。 ）9. 一旦你选择或创建了一个AB包，你还可以在右边的另一个下拉菜单中分配或创建一个`Variants`。但构建AB包不需要`Variants`。### 打一个AB包``` C#using UnityEditor; using System.IO; public class CreateAssetBundles &#123; [MenuItem(&quot;Assets/Build AssetBundles&quot;)] static void BuildAllAssetBundles() &#123; string assetBundleDirectory = &quot;Assets/AssetBundles&quot;; if(!Directory.Exists(assetBundleDirectory)) &#123; Directory.CreateDirectory(assetBundleDirectory); &#125; BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows); &#125; &#125; assetBundleDirectory：AssetBundleDirectory的输出文件夹 BuildAssetBundleOptions：有三个BuildAssetBundleOptions选项决定了AB包压缩算法 BuidAssetBundleOptions.None默认打包选项，使用全文压缩（LZMA）打包。包体更小，适合需要下载的AB包；但缺点是，读取一个资产需要加载AB包全部资产。 BuidAssetBundleOptions.UncompressedAssetBundle以完全不压缩数据的方式打包。未压缩的缺点是文件下载尺寸较大。然而，下载后的加载时间会快很多。未压缩的AB包是16字节对齐的。 BuildAssetBundleOptions.ChunkBasedCompression使用基于块的压缩（LZ4）打包。在AB包内，每128KB的内容就被压缩一次。文件大小会比LZMA大；但是，可以有选择的检索和加载资产。加载时间和加载未压缩的AB包相当，但更小。 [[关于压缩#AB包的压缩]] BuildTarget可以选择不同平台来打包，使用activeBuildTarget可以根据现在选择的平台打包。 下载和加载AB包和资产AB包可以分布在下面几个地方 StreamingAssets文件夹中，需要在Player build中引用。 由网络服务托管，使用·UnityWebRequestAssetBundle·下载。 通过你自己的下载或安装代码进行分发。这种方法需要更多的开发工作，但确实提供了灵活性，在使用Unity API加载文件之前，可以完全控制压缩、缓存、修补和验证等方面。 如何准备资产定义AB包有一下规则 场景和资产不能放在同一个AB包中。一个单独的AB包只能包含场景或资产。 一个特定的场景或资产不能分配给一个以上的AB包。 AB包不能包含脚本资产 StreamingAssets文件夹中的文件不能放AB包中。 AB包的名称不能与输出文件夹的名称一致虽然可以自由的分配AssetBundles的资产，但有一些分组策略会很有用。 Logical Entity Grouping逻辑实体分组是指根据资产所代表的项目功能部分将其分配给资产包。这包括诸如用户界面、角色、环境和其他任何可能在应用程序的生命周期中频繁出现的部分。 Type Grouping将把类型相似的资产，如音轨或语言本地化文件，分配给一个资产包。 Concurrent Content Grouping并发内容分组是指你将资产捆绑在一起，在同一时间加载和使用。你可以认为这些类型的捆绑用于基于关卡的游戏，每个关卡都包含完全独特的角色、纹理、音乐等。你要绝对确定这些资产包中的某项资产只在该资产包中的其他资产被使用时才会被使用。在一个并发内容分组捆绑中，对单一资产的依赖将导致加载时间的显著增加。你将被迫下载整个捆绑包的单一资产。 Tips: 将经常更新的对象与很少变化的对象分开到AssetBundles中。 将可能被同时加载的对象分为一组。比如一个模型，它的纹理，和它的动画。 如果你注意到多个AssetBundles中的多个对象依赖于一个完全不同的AssetBundle中的一个资产，请将这个依赖关系转移到一个单独的AssetBundle中。如果几个AssetBundles引用了其他AssetBundles中的同一组资产，可能值得将这些依赖关系拉到一个共享的AssetBundle中以减少重复。 如果两组对象不太可能同时被加载，例如标准和高清资产，请确保它们分离在自己的资产包中。 如果一个资产包中只有不到50%的内容经常被同时加载，那么可以考虑将该资产包拆开。 考虑合并规模较小（少于五到十个资产）但其内容经常被同时加载的资产包。 如果一组对象只是同一对象的不同版本，可以考虑资产包的变量。 AB包依赖如果两个资产都在AB包中，当一个资源引用另一个资产时会发送AB包依赖；如果这个资产不在另一个AB包中，AB包会复制这个资产到自己的AB中。如果多个AB包引用同一个资产，可以把这个资产打一个AB包，避免多次复制。 生成的输出编译成功的ab包有2*(n+1)个文件，对于你在编辑器中指定的每一个AssetBundle，你会注意到一个文件，其中有你的AssetBundle名称和你的AssetBundle名称+”.manifest”。还会有一个额外的捆绑和清单，与您创建的任何AssetBundle不共享一个名字。相反，它是以它所在的目录命名的（AssetBundles被构建到哪里），这就是Manifest Bundle。这个捆绑包包含了AssetBundleManifest对象，它对于确定在运行时要加载哪些捆绑包的依赖关系非常有用。 AssetBundle文件这个文件是你在运行时要用来加载资产的文件，它缺少了.manifest文件。内部包含多个文件的存档。![[Pasted image 20230315111655.png]]主文件使用Unity的二进制序列化格式。它包含了AssetBundle对象和AssetBundle中所有资产（显式或隐式）的对象。任何音频、视频内容将被存储在一个.resource文件中，任何纹理数据将被存储在一个.resS文件中。 Manifest文件对于每一个生成的包，包括额外的清单包，都会生成一个相关的清单文件。清单文件的扩展名为.manifest，可以用任何文本编辑器打开。它包含循环冗余检查（CRC）数据和捆绑包的依赖性数据等信息。普通资产包的清单文件看起来是这样的。12345678910111213ManifestFileVersion: 0CRC: 2422268106 Hashes: AssetFileHash: serializedVersion: 2 Hash: 8b6db55a2344f068cf8a9be0a662ba15 TypeTreeHash: serializedVersion: 2 Hash: 37ad974993dbaa77485dd2a0c38f347a HashAppended: 0 ClassTypes: - Class: 91 Script: &#123;instanceID: 0&#125; Assets: Asset_0: Assets/Mecanim/StateMachine.controller Dependencies: &#123;&#125; Manifest Bundle还有两个额外的文件会生成。 第一个是一个小的AssetBundle，以它所在的目录命名（AssetBundles被构建到哪里）。这个文件被称为Manifest Bundle，它包含了AssetBundleManifest对象，用于确定在运行时要加载哪些AB包依赖。[Using AssetBundles Natively] 还会为Manifest Bundle生成一个.manifest文件。其内容大致如下：123456ManifestFileVersion: 0 AssetBundleManifest: AssetBundleInfos: Info_0: Name: scene1assetbundle Dependencies: &#123;&#125;Manifest Bundle的.manifest文件记录了AB包的关系，以及它们的依赖关系是什么。这与Manifest Bundle内的AssetBundleManifest对象所记录的信息类似，由于它是一个文本文件，所以便于人类阅读和外部工具的解析。这个.manifest文件对于防止您在AB包中使用的类型的代码剥离非常重要，如果这些类型不被您的Player build中的内容所使用。如果在您的Player Settings中启用了代码剥离功能则应在执行播放器构建时通过设置BuildPlayerOptions.assetBundleManifestPath传递该清单的路径。[分布大小和代码剥离]。 使用原生AB包有两个不同的API，用来加载AB包。 AssetBundle对象上的静态加载方法，例如AssetBundle.LoadFromFile。 UnityWebRequest对资产包的支持，例如UnityWebRequestAssetBundle.GetAssetBundle。AssetBundle.LoadFromFile这个API在从本地存储加载未压缩和分块压缩包（LZ4）时效率很高，因为它可以直接从磁盘上增量读取文件的内容。使用这种方法加载一个被全文件压缩的文件(LZMA)的文件时，效率较低，因为它需要先将文件完全解压到内存中。 123456789101112131415public class LoadFromFileExample : MonoBehaviour &#123; void Start() &#123; //AssetBundle.LoadFromFileAsync异步加载，比如AB包不在本地 var myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;)); if (myLoadedAssetBundle == null) &#123; Debug.Log(&quot;Failed to load AssetBundle!&quot;); return; &#125; var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;); Instantiate(prefab); &#125; &#125; UnityWebRequestAssetBundle如果你的资产包是在线托管的，或者你运行的平台不支持直接访问文件系统，那么就使用UnityWebRequestAssetBundle API。12345678910IEnumerator InstantiateObject() &#123; string url = &quot;file:///&quot; + Application.dataPath + &quot;/AssetBundles/&quot; + assetBundleName; var request = UnityEngine.Networking.UnityWebRequestAssetBundle.GetAssetBundle(url, 0); yield return request.Send(); AssetBundle bundle = UnityEngine.Networking.DownloadHandlerAssetBundle.GetContent(request); GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;); Instantiate(cube); Instantiate(sprite); &#125;为了简单起见，这个例子显示了代码中硬编码的CRC值。但在实践中，您的资产包的预期CRC值将被单独下载，或在下载资产包之前从文件中检索。请参阅资产包下载的完整性和安全性。 注意：为了避免每次调用此代码时下载整个AssetBundle内容，你可以为你的AssetBundle启用缓存。这是通过调用UnityWebRequestAssetBundle.GetAssetBundle时传递AB包的哈希值来实现的。哈希值可以从AssetBundle Manifest中获得。该哈希值作为你所请求的资产包的精确构建的版本标识。请参阅AssetBundle压缩和缓存，了解缓存的细节和压缩的相关注意事项。 从AB包加载资产https://docs.unity3d.com/2023.1/Documentation/Manual/AssetBundles-Native.html 为AssetBundles准备资产","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"Doing","slug":"Doing","permalink":"http://www.xiaogou134.games/tags/Doing/"}]},{"title":"Coroutine","slug":"Coroutine","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.507Z","comments":true,"path":"2023/04/17/Coroutine/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/Coroutine/","excerpt":"","text":"Coroutinecoroutine允许你将任务分散到几个帧中。在Unity中，coroutine是一个可以暂停执行并将控制权返回给Unity的方法，但在下一帧继续执行它所离开的地方。 在大多数情况下，当你调用一个方法时，它会运行到完成，然后将控制权返回给调用方法，再加上任何可选的返回值。这意味着在一个方法中发生的任何动作都必须在单帧更新中发生。 在你想用一个方法调用来包含一个程序性动画或一个随时间变化的事件序列的情况下，你可以使用一个循环程序。 然而，重要的是要记住，coroutines并不是线程。在coroutine中运行的同步操作仍然在主线程上执行。如果你想减少花在主线程上的CPU时间，那么避免在coroutine中进行阻塞操作就和在其他脚本代码中一样重要。如果你想在Unity中使用多线程代码，可以考虑使用C#作业系统。 如果你需要处理长时间的异步操作，如等待HTTP传输、资产加载或文件I/O完成，最好使用coroutines。深究Coroutine原理[自动生成状态机]https://csharpindepth.com/Articles/IteratorBlockImplementation","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"Doing","slug":"Doing","permalink":"http://www.xiaogou134.games/tags/Doing/"}]},{"title":"DOTWEEN","slug":"DOTWEEN","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.507Z","comments":true,"path":"2023/04/17/DOTWEEN/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/DOTWEEN/","excerpt":"","text":"Documentation","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"ToDo","slug":"ToDo","permalink":"http://www.xiaogou134.games/tags/ToDo/"}]},{"title":"Entities.Graphics","slug":"Entities.Graphics","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2023/04/17/Entities.Graphics/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/Entities.Graphics/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"ToDo","slug":"ToDo","permalink":"http://www.xiaogou134.games/tags/ToDo/"}]},{"title":"Entities","slug":"Entities","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2023/04/17/Entities/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/Entities/","excerpt":"","text":"ecs-packages 使用的包DOTS技术使用的包 Entities C# Job System Burst compiler Collections MathmaticsECS包 Unity Physics Havok Physics for Unity Netcode for Entities Entitites Graphics Entities包是Unity面向数据的技术栈（DOTS）的一部分，为实体组件系统（ECS）架构提供了面向数据的实现。 Recommended packages[[Entities.Graphics]] IDE supportMicrosoft Source Generator Domain Reload Setting为什么要把Reload Domain和Reload Scene关闭","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"Doing","slug":"Doing","permalink":"http://www.xiaogou134.games/tags/Doing/"}]},{"title":"InputSytem","slug":"InputSystem","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2023/04/17/InputSystem/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/InputSystem/","excerpt":"","text":"InputSystem 基本概念![[ConceptsOverview.svg]]|概念|描述||—-|—|| [[InputSystem#User]]|玩你的游戏或使用你的应用程序的人，通过手持或触摸输入设备并提供输入。||[[InputSystem#InputDevice]]|提供输入的物理硬件，通常只被称为 “设备”。如键盘、游戏板、鼠标或触摸屏，允许用户向Unity发送输入。||Controls|一个输入设备的独立的个体部分，它们各自向Unity发送输入值。例如，游戏手柄的控制包括多个按钮、摇杆和触发器，而鼠标的控制包括底部的两个X和Y传感器，以及顶部的各种按钮和滚轮。 ||Interactions|描述控制输入设备的不同方式。例如，按下一个按钮，松开一个按钮，长按或双击。互动可以被认为是 “输入的模式”。输入系统提供了识别和响应不同类型互动的方法。 ||Actions|用户输入对应于游戏或应用中的动作，不管他们用什么设备或控件来执行。动作通常有概念性的名称，你可以根据你的项目选择，通常应该是动词。例如 “运行”、”跳跃”、”蹲下”、”使用”、”开始”、”退出”。输入系统可以帮助你管理和编辑你的动作，或者你可以自己实现它们。 ||Action Asset|一种资产，它允许你定义和配置一组动作，作为一个集合。动作资产界面允许你绑定控件，将相关的动作归入动作图，并指定哪些控件属于不同的控制方案。 ||Embedded Actions| 在脚本中直接定义为字段的动作（而不是在动作资产中）。这些类型的动作与动作资产中定义的动作是一样的，用检查器界面绑定控件。然而，由于它们被定义为你脚本中的单个字段，你不能从动作资产的能力中获益，即把动作组合成动作图和控制方案。 ||Binding|一个动作和一个或多个控制之间定义的连接。例如，在一个赛车游戏中，按下控制器上的右肩按钮可能会被绑定到 “换挡 “的动作上。动作资产和嵌入式动作都提供一个类似的用户界面来创建和编辑绑定。 | UserInput System通过InputUser支持多用户管理。 Input Device","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"Doing","slug":"Doing","permalink":"http://www.xiaogou134.games/tags/Doing/"}]},{"title":"Localization","slug":"Localization","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2023/04/17/Localization/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/Localization/","excerpt":"","text":"Localization","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"ToDo","slug":"ToDo","permalink":"http://www.xiaogou134.games/tags/ToDo/"}]},{"title":"Meshs,Materials, Shaders and Textures","slug":"Meshs,Materials,Shaders and Textures","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2023/04/17/Meshs,Materials,Shaders and Textures/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/Meshs,Materials,Shaders%20and%20Textures/","excerpt":"","text":"Meshs,Materials, Shaders and Textures Meshes（网络） 是Unity的主要图形元素，定义了一个物体的形状。 Shader是基于照明输入和材质配置，计算每个像素渲染颜色的数学计算和算法的小脚本。 Textures（纹理） 是位图图像。一个材质可以包含对纹理的引用，这样材质的shader就可以在计算GameObject的表面颜色时使用这些纹理。除了GameObject表面的基本颜色（[[Albedo]]）之外，纹理还可以表示材料表面的许多其他方面，如它的反射率或粗糙度。 MeshesMeshes 在图形学中，你将网格和材质一起使用；网格描述了GPU渲染的物体的形状，而材质描述了物体表面的外观。 在物理学中，你可以使用网格来确定碰撞器的形状。 Deformable meshes可变形网格分为以下几类。 Skinned meshes ：这些网格与称为骨骼的额外数据一起工作。骨头形成了一个叫做骨架的结构（也叫rig，或joint hierarchy关节层次结构），Skinned meshes包含了一些数据，当骨架移动时，它可以以一种真实的方式变形。你通常用Unity的动画功能将蒙皮网格用于Skinned meshesv，但你也可以将它们与Rigidbody组件一起使用来创建 “布娃娃（[[ragdoll]]） “效果。 Meshes with blend shape：这些网格包含称为混合形状的数据。混合形状描述了被变形为不同形状的网格版本，Unity在它们之间进行插值。你可以使用混合形状来做变形目标动画，这是面部动画的一种常见技术。 与Cloth组件配合使用的网格可以进行逼真的织物模拟。 Materials（材质） 定义一个表面应该如何被渲染，包括对它所使用的纹理、平铺信息、颜色色调等的引用。材质的可用选项取决于该材质使用的着色器。 TextureTextuers纹理只是一个标准的位图图像，它被贴在网格表面。 3D模型的纹理使用 “材质 “将纹理应用于对象，材质使用专门的图形程序Shader来渲染网格表面的纹理。你应该把你的纹理做成2的幂的尺寸（例如32x32、64x64、128x128、256x256，等等）。 2D在2D游戏中，Sprites是通过应用于平面网格的纹理来实现的，这些网格接近物体的形状。 GUI一个游戏的图形用户界面（GUI）由不直接用于游戏场景的图形组成,但允许玩家做出选择和查看信息。这些图形显然与用于细化网格表面的图形非常不同，但它们还是使用标准的Unity纹理来处理 Particles粒子是一个小的2D图形，代表了基本上是流体或气态的东西的一小部分。当许多这样的粒子被一次性创建并设置为运动状态时，可以选择随机变化，它们可以创造出非常有说服力的效果。 Terain Heightmaps在灰度图像中，每个像素值都是一个数字，对应于图像中该点的灰度。 值是一个简单的数字，对应于图像中该点的灰色阴影（可以是0…1范围内的一个值，例如，0是黑色，1是白色），可用地形高度图。","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"Doing","slug":"Doing","permalink":"http://www.xiaogou134.games/tags/Doing/"}]},{"title":"Shader","slug":"Shader","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2023/04/17/Shader/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/Shader/","excerpt":"","text":"Shaders core conceptsShaders introductionshader大致有3中类型 作为图形管道一部分的着色器是最常见的着色器类型。它们进行计算，决定屏幕上像素的颜色在屏幕上的颜色。在Unity中，你通常通过使用Shader对象来处理这种类型的着色器。 Compute shaders（计算着色器） 在GPU上进行计算，在常规图形管道之外。 Ray tracing（光线追踪） 着色器执行与光线追踪有关的计算。也有一些术语 shader or shader program 在GPU上运行的程序。除非另有说明，这是指作为图形管道一部分的着色器程序。 Shader object Shader类的一个实例。着色器对象是对着色器程序和其他信息的封装。 ShaderLab 一种用于编写着色器的Unity特定语言。 Shader Graph 一个用于创建着色器的工具，无需编写代码。 shader asset 在你的Unity项目中以.shader为扩展名的文件。它定义了一个Shader对象。 Shader Graph asset 你的Unity项目中的一个文件。它定义了一个Shader对象。Asynchronous shader compilation","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"Doing","slug":"Doing","permalink":"http://www.xiaogou134.games/tags/Doing/"}]},{"title":"Timeline","slug":"Timeline","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2023/04/17/Timeline/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/Timeline/","excerpt":"","text":"Timeline","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.xiaogou134.games/tags/Todo/"}]},{"title":"Unity里的机器学习","slug":"Unity里的机器学习","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2023/04/17/Unity里的机器学习/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/Unity%E9%87%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"ML-Agents这是官网提供的库ml-agnetsProximal Policy Optimization (PPO)Soft Actor-Critic (SAC)","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"Doing","slug":"Doing","permalink":"http://www.xiaogou134.games/tags/Doing/"}]},{"title":"Ragdoll","slug":"ragdoll","date":"2023-04-17T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2023/04/17/ragdoll/","link":"","permalink":"http://www.xiaogou134.games/2023/04/17/ragdoll/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Unity","slug":"Unity","permalink":"http://www.xiaogou134.games/categories/Unity/"}],"tags":[{"name":"ToDo","slug":"ToDo","permalink":"http://www.xiaogou134.games/tags/ToDo/"}]},{"title":"线性回归的表达方式","slug":"线性回归的表达方式","date":"2021-05-30T16:28:00.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2021/05/30/线性回归的表达方式/","link":"","permalink":"http://www.xiaogou134.games/2021/05/30/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E8%A1%A8%E8%BE%BE%E6%96%B9%E5%BC%8F/","excerpt":"","text":"神经网络图输出层中的神经元和输入层中各个输入完全连接，这样的输出层又叫全连接层（fully-connected layer）或稠密层（dense layer）。 矢量计算表达式在模型训练或预测时，我们常常会同时处理多个数据样本并用到矢量计算。 1234import torchfrom time import timea = torch.ones(1000)b = torch.ones(1000) 123456# 向量逐一相加，实现向量相加start = time()c = torch.zeros(1000)for i in range(1000): c[i] = a[i] + b[i]print(time() - start) 0.029059171676635742 1234# 或者直接做矢量加法。start = time()d = a + bprint(time() - start) 0.00018215179443359375 结果很明显，后者比前者更省时。因此，我们应该尽可能采用矢量计算，以提升计算效率。 123a = torch.ones(3)b = 10print(a + b) tensor([11., 11., 11.]) 当数据样本数为 $n$ ，特征数为 $d$ 时，线性回归的矢量计算表达式为\\begin{equation}\\hat{y}=Xw+b\\end{equation}其中模型输出 $\\hat{y} \\in \\mathbb{R}^{n\\times I}$ 批量数据样本特征 $X\\in \\mathbb{R}^{n\\times 1}$ ，权重$ w \\in \\mathbb{R}^{d\\times I}$ 偏差$ b \\in \\mathbb{R} $。相应地，批量数据样本标签$ y \\in \\mathbb{R}^{n\\times 1}$ 。设模型参数$ \\theta = [w_1, w_2, b]^T $,我们可以重写损失函数为\\begin{equation}\\ell(\\theta)=\\frac{1}{2n}(\\hat{y}-y)^T(\\hat{y}-y)\\end{equation}小批量随机梯度下降的迭代步骤将相应地改写为\\begin{equation}\\theta \\leftarrow \\theta - \\frac{\\eta}{|\\beta|}\\sum_{i \\in \\beta} \\nabla_{\\theta}\\ell^{(i)}(\\theta)\\end{equation}其中梯度是损失有关3个为标量的模型参数的偏导数组成的向量：\\begin{equation}\\nabla_{\\theta}\\ell^{(i)}(\\theta)\\end{equation}","raw":null,"content":null,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://www.xiaogou134.games/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://www.xiaogou134.games/tags/pytorch/"}]},{"title":"PyTorch数据操作","slug":"PyTorch数据操作","date":"2021-05-23T00:00:00.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2021/05/23/PyTorch数据操作/","link":"","permalink":"http://www.xiaogou134.games/2021/05/23/PyTorch%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1数据操作 tensor这个单词一般可译作“张量”，张量可以看作是一个多维数组。标量可以看作是0维张量，向量可以看作1维张量，矩阵可以看作是二维张量。 1.1创建 Tensor1import torch 12x = torch.empty(5, 3)print(x) tensor([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) 数字后点是浮点数 12x = torch.rand(5, 3)print(x) tensor([[0.5903, 0.9750, 0.5636], [0.4716, 0.8525, 0.2172], [0.8911, 0.7420, 0.1079], [0.9797, 0.1777, 0.4865], [0.0200, 0.6187, 0.5814]]) 12x = torch.zeros(5, 3, dtype=torch.long)print(x) tensor([[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]) 12x = torch.tensor([5.5, 3])print(x) tensor([5.5000, 3.0000]) 12345x = x.new_ones(5, 3, dtype = torch.float64)print(x)x = torch.randn_like(x, dtype=torch.float)print(x) tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], dtype=torch.float64) tensor([[ 0.8706, 0.5820, -0.2114], [ 1.1337, -0.2393, -1.4247], [-0.6172, -1.5335, -0.2155], [ 0.6623, 0.0259, -0.3239], [ 0.3360, 0.2266, 0.0176]]) 12print(x.size())print(x.shape) torch.Size([5, 3]) torch.Size([5, 3]) 12torch.arange(10,100,10) # 步长多少torch.linspace(10,100,10) # 等分为多少份 tensor([10, 20, 30, 40, 50, 60, 70, 80, 90]) 函数 功能 Tensor(*sizes) 基础构造函数 tensor(data,) 类似np.array的构造函数 ones(*sizes) 全1Tensor zeros(*sizes) 全0Tensor eye(*sizes) 对角线为1，其他为0 arange(s,e,step) 从s到e，步长为step linspace(s,e,steps) 从s到e，均匀切分成steps份 rand/randn(*sizes) 均匀/标准分布 normal(mean,std)/uniform(from,to) 正态分布/均匀分布 randperm(m) 随机排列 1.2操作 Tensor12y = torch.rand(5, 3)print(x + y) # 加法形式一 tensor([[ 1.3266, 1.3956, -0.1592], [ 1.9405, -0.0986, -0.9286], [-0.5569, -0.5589, -0.2075], [ 1.4142, 1.0082, 0.5748], [ 0.8840, 0.6449, 0.0540]]) 1print(torch.add(x, y)) # 加法形式二 123result = torch.empty(5, 3)torch.add(x, y, out=result) print(result) tensor([[ 1.3266, 1.3956, -0.1592], [ 1.9405, -0.0986, -0.9286], [-0.5569, -0.5589, -0.2075], [ 1.4142, 1.0082, 0.5748], [ 0.8840, 0.6449, 0.0540]]) 12y.add_(x)print(y) # 加法形式三(inplace) tensor([[ 1.3266, 1.3956, -0.1592], [ 1.9405, -0.0986, -0.9286], [-0.5569, -0.5589, -0.2075], [ 1.4142, 1.0082, 0.5748], [ 0.8840, 0.6449, 0.0540]]) inplace操作指的就是进行原地操作，选择进行原地覆盖运算。操作的好处就是可以节省运算内存，不用多储存其他无关变量。PyTorch中inplace版本都有后缀_ 索引我们还可以使用类似NumPy的索引操作来访问Tensor的一部分，需要注意的是：索引出来的结果与原数据共享内存，也即修改一个，另一个会跟着修改。 1234y = x[0, :]y += 1print(y)print(x[0, :]) # 原 torch 也改变了 tensor([1.8706, 1.5820, 0.7886]) tensor([1.8706, 1.5820, 0.7886]) 函数 功能 index_select(input, dim, index) 在指定维度dim上选取，比如选取某些行、某些列 masked_select(input, mask) 例子如上，a[a&gt;0]，使用ByteTensor进行选取 nonzero(input) 非0元素的下标 gather(input, dim, index) 根据index，在dim维度上选取数据，输出的size与index一样 改变形状用view()来改变Tensor的形状： 123y = x.view(15)z = x.view(-1, 5) # -1所指的维度可以根据其他维度的值推出来print(x.size(), y.size(), z.size()) torch.Size([5, 3]) torch.Size([15]) torch.Size([3, 5]) 注意view()返回的新Tensor与源Tensor虽然可能有不同的size，但是是共享data的，也即更改其中的一个，另外一个也会跟着改变。(顾名思义，view仅仅是改变了对这个张量的观察角度，内部数据并未改变) 123x += 1print(x)print(y) # 也改了 tensor([[ 2.8706, 2.5820, 1.7886], [ 2.1337, 0.7607, -0.4247], [ 0.3828, -0.5335, 0.7845], [ 1.6623, 1.0259, 0.6761], [ 1.3360, 1.2266, 1.0176]]) tensor([ 2.8706, 2.5820, 1.7886, 2.1337, 0.7607, -0.4247, 0.3828, -0.5335, 0.7845, 1.6623, 1.0259, 0.6761, 1.3360, 1.2266, 1.0176]) 所以如果我们想返回一个真正新的副本（即不共享data内存）。推荐先用clone创造一个副本然后再使用view。 1234x_cp = x.clone().view(15)x -= 1print(x)print(x_cp) tensor([[ 1.8706, 1.5820, 0.7886], [ 1.1337, -0.2393, -1.4247], [-0.6172, -1.5335, -0.2155], [ 0.6623, 0.0259, -0.3239], [ 0.3360, 0.2266, 0.0176]]) tensor([ 2.8706, 2.5820, 1.7886, 2.1337, 0.7607, -0.4247, 0.3828, -0.5335, 0.7845, 1.6623, 1.0259, 0.6761, 1.3360, 1.2266, 1.0176]) 使用clone还有一个好处是会被记录在计算图中，即梯度回传到副本时也会传到源Tensor。 item()可以将一个标量Tensor转换成一个Python number 123x = torch.randn(1)print(x)print(x.item()) tensor([0.8250]) 0.825013279914856 线性代数线性代数的操作已经定义，可以查查有没有 函数 功能 trace 对角线元素之和(矩阵的迹) diag 对角线元素 triu/tril 矩阵的上三角/下三角，可指定偏移量 mm/bmm 矩阵乘法，batch的矩阵乘法 addmm/addbmm/addmv/addr/baddbmm.. 矩阵运算 t 转置 dot/cross 内积/外积 inverse 求逆矩阵 svd 奇异值分解 1.3 广播机制当对两个形状不同的Tensor按元素运算时，可能会触发广播（broadcasting）机制：先适当复制元素使这两个Tensor形状相同后再按元素运算。 12345x = torch.arange(1, 3).view(1, 2)print(x)y = torch.arange(1, 4).view(3, 1)print(y)print(x + y) tensor([[1, 2]]) tensor([[1], [2], [3]]) tensor([[2, 3], [3, 4], [4, 5]]) 1.4 运算的内存开销索引操作是不会开辟新内存的，而像y = x + y这样的运算是会新开内存的，然后将y指向新内存。 12345x = torch.tensor([1, 2])y = torch.tensor([3, 4])id_before = id(y) # id求指针y = y + xprint(id(y) == id_before) False 12345x = torch.tensor([1, 2])y = torch.tensor([3, 4])id_before = id(y)y[:] = y + x # 将y的值替换到原来的索引中print(id(y) == id_before) True 还可以使用运算符全名函数中的out参数或者自加运算符+=(也即add_())达到上述效果。 12345x = torch.tensor([1, 2])y = torch.tensor([3, 4])id_before = id(y)torch.add(x, y, out=y) # y += x, y.add_(x)也可以print(id(y) == id_before) True 注：虽然view返回的Tensor与源Tensor是共享data的，但是依然是一个新的Tensor（因为Tensor除了包含data外还有一些其他属性），二者id（内存地址）并不一致。 1.5 Tensor和NumPy相互转换我们很容易用numpy()和from_numpy()将Tensor和NumPy中的数组相互转换。但是需要注意的一点是： 这两个函数所产生的的Tensor和NumPy中的数组共享相同的内存（所以他们之间的转换很快），改变其中一个时另一个也会改变！！！ 还有一个常用的将NumPy中的array转换成Tensor的方法就是torch.tensor(), 需要注意的是，此方法总是会进行数据拷贝（就会消耗更多的时间和空间），所以返回的Tensor和原来的数据不再共享内存。 Tensor转NumbPy12345678a = torch.ones(5)b = a.numpy()print(a, b)a += 1print(a, b)b += 1print(a, b) tensor([1., 1., 1., 1., 1.]) [1. 1. 1. 1. 1.] tensor([2., 2., 2., 2., 2.]) [2. 2. 2. 2. 2.] tensor([3., 3., 3., 3., 3.]) [3. 3. 3. 3. 3.] 123456789import numpy as npa = np.ones(5)b = torch.from_numpy(a)print(a, b)a += 1print(a, b)b += 1print(a, b) [1. 1. 1. 1. 1.] tensor([1., 1., 1., 1., 1.], dtype=torch.float64) [2. 2. 2. 2. 2.] tensor([2., 2., 2., 2., 2.], dtype=torch.float64) [3. 3. 3. 3. 3.] tensor([3., 3., 3., 3., 3.], dtype=torch.float64) 所有在CPU上的Tensor（除了CharTensor）都支持与NumPy数组相互转换。 此外上面提到还有一个常用的方法就是直接用torch.tensor()将NumPy数组转换成Tensor，需要注意的是该方法总是会进行数据拷贝，返回的Tensor和原来的数据不再共享内存。 123c = torch.tensor(a)a += 1print(a, c) [4. 4. 4. 4. 4.] tensor([3., 3., 3., 3., 3.], dtype=torch.float64) 1.6 Tensor on GPU用方法to()可以将Tensor在CPU和GPU（需要硬件支持）之间相互移动。` 12345678# 以下代码只有在PyTorch GPU版本上才会执行if torch.cuda.is_available(): device = torch.device(&quot;cuda&quot;) # GPU y = torch.ones_like(x, device=device) # 直接创建一个在GPU上的Tensor x = x.to(device) # 等价于 .to(&quot;cuda&quot;) z = x + y print(z) print(z.to(&quot;cpu&quot;, torch.double)) # to()还可以同时更改数据类型","raw":null,"content":null,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://www.xiaogou134.games/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://www.xiaogou134.games/tags/pytorch/"}]},{"title":"PyTorch里的一些函数","slug":"PyTorch里的一些函数","date":"2021-05-23T00:00:00.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2021/05/23/PyTorch里的一些函数/","link":"","permalink":"http://www.xiaogou134.games/2021/05/23/PyTorch%E9%87%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/","excerpt":"","text":"PyTorch里的一些函数Lineartorch.nn.Linear(in_features, out_features, bias=True, device=None, dtype=None) 作用：对数据进行线性变化 $ y = xA^T+b $ 参数： in_features输入样本的大小 out_features输出样本的大小 bias如果False，这一层不会学习加法偏差（就是b） 12345m = nn.Linear(20, 30)input = torch.randn(128, 20)output = m(input)print(output.size())# torch.Size([128, 30]) Parametertorch.nn.parameter 作用：首先可以把这个函数理解为类型转换函数，将一个不可训练的类型Tensor转换成可以训练的类型parameter并将这个parameter绑定到这个module里面(net.parameter()中就有这个绑定的parameter，所以在参数优化的时候可以进行优化的)，所以经过类型转换这个self.v变成了模型的一部分，成为了模型中根据训练可以改动的参数了。使用这个函数的目的也是想让某些变量在学习的过程中不断的修改其值以达到最优化。 FLattentorch.nn.Flatten(start_dim=1, end_dim=1) Input:$（N，*dims)$ Output:$(N, \\prod*dims)$ 把一个连续的变暗范围变平成一个张量。与顺序使用。 12345678input = torch.randn(32, 1, 5, 5)m = nn.Sequential( nn.Conv2d(1, 32, 5, 1, 1), nn.Flatten())output = m(input)output.size()# torch.Size([32, 288]) tensor生成函数torch.linspace(start, end, steps, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor生成一串线性变化的tensor torch.randn(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor生成一串随机tensor torch.full(size, fill_value, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor生成一串所有值相同的tensor","raw":null,"content":null,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://www.xiaogou134.games/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://www.xiaogou134.games/tags/pytorch/"}]},{"title":"类的初始化","slug":"类的初始化","date":"2021-05-19T12:06:00.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2021/05/19/类的初始化/","link":"","permalink":"http://www.xiaogou134.games/2021/05/19/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"123class Dog &#123;&#125;let a = Dog() 最简单的初始化，就像函数一样（使用了类中隐式的初始化器）。 1234567init(//通过参数区分不同的init器)&#123; // 在init里必须为没有值的变量赋值（如果实在不想赋值，可以设置为可选变量，初始为nil） // 用self区别属性和参数，但其他位置尽量不用 // 在初始化结束之前可以修改常量 // 在全部初始完之前，尽量不要调用方法&#125; 当自己实现了初始化器，隐式的初始化器就消失了 指定构造器 便利构造器 类中最主要的构造器 类中比较次要的、辅助型的构造器 初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。 可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入的实例。 每一个类都必须拥有至少一个指定构造器 只在必要的时候为类提供便利构造器 Init(parameters) &#123; statements &#125; convenience init(parameters) &#123; statements &#125; 遵守了NSCoding协议的类，必须实现这个，UIView为代表 123required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:)&quot;) has not been implemented&quot;) &#125; 遵守了NSCoding protoaol的所有类必须继承。只是有的情况会隐式继承，而有的情况下需要显示实现。 什么情况下要显示添加：当我们在子类定义了指定初始化器(包括自定义和重写父类指定初始化器)，那么必须显示实现required init?(coder aDecoder: NSCoder)，而其他情况下则会隐式继承，我们可以不用理会。 什么情况下会调用：当我们使用storyboard实现界面的时候，程序会调用这个初始化器。注意要去掉fatalError，fatalError的意思是无条件停止执行并打印。","raw":null,"content":null,"categories":[{"name":"swift","slug":"swift","permalink":"http://www.xiaogou134.games/categories/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://www.xiaogou134.games/tags/swift/"}]},{"title":"模式匹配","slug":"模式匹配","date":"2021-05-17T14:21:00.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2021/05/17/模式匹配/","link":"","permalink":"http://www.xiaogou134.games/2021/05/17/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"","text":"模式类型swift有7种模式，可以在switch，if，guard和for里用 通配符模式_ _表示忽略这个值，但nil除外 _?表示对可选的通配 标识符模式 直接指明值或者类型 值绑定模式 let (x, y) = ()比较像值绑定的方式 神奇的用法 12345func usernameAndPassword() -&gt; (username: String, password: String)? &#123; ... &#125;switch usernameAndPassword() &#123; case let(_, password)? where password == &#x27;12345&#x27;: login() default: logout()&#125; 元组模式 匹配为元组 123456789let age = 23let job: String? = &quot;Operator&quot;let payload: Any = NSDictionary()switch (age, job, payload) &#123;case (let age, _?, _ as NSDictionary): print(age)default: ()&#125; 枚举case模式 匹配枚举 12345678switch e &#123; case let .soldier(x, y): drawImage(&quot;soldier.png&quot;, x, y) case let .tank(x, y): drawImage(&quot;tank.png&quot;, x, y) case let .player(x, y): drawImage(&quot;player.png&quot;, x, y)&#125; 类型转换模式 is：只是匹配，所以caseblock里不知道匹配的什么类型 as：匹配然后重铸 表达式模式 将switch的值应用~=操作符（类自己有定义） 1234switch 5 &#123;case 0..10: print(&quot;In range 0-10&quot;)default: print(&quot;In another range&quot;)&#125; 如果重构~=操作符，可以实现更多的内容 12345678910111213struct Soldier &#123; let hp: Int let x: Int let y: Int&#125;func ~= (pattern: Int, value: Soldier) -&gt; Bool &#123; return pattern == value.hp&#125;let soldier = Soldier(hp: 99, x: 10, y: 10)switch soldier &#123;case 0: print(&quot;dead soldier&quot;)default: ()&#125; 如果类是Equatable类型，类可以与类匹配。pattern遵循一个协议的话，可以与任何遵循协议的类匹配 if, for, gurad 中的使用1234567891011121314151617181920212223func valueTupleType(a: (Int, Any)) -&gt; Bool &#123; // guard case Example guard case let (x, _ as String) = a else &#123; return false&#125; print(x) // for case example for case let (a, _ as String) in [a] &#123; print(a) &#125; // if case example if case let (x, _ as String) = a &#123; print(&quot;if&quot;, x) &#125; // switch case example switch a &#123; case let (a, _ as String): print(a) return true default: return false &#125;&#125;","raw":null,"content":null,"categories":[{"name":"swift","slug":"swift","permalink":"http://www.xiaogou134.games/categories/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://www.xiaogou134.games/tags/swift/"}]},{"title":"MVC在swift里怎么用","slug":"MVC在swift里怎么用","date":"2021-05-16T14:56:41.000Z","updated":"2023-04-19T16:03:49.511Z","comments":true,"path":"2021/05/16/MVC在swift里怎么用/","link":"","permalink":"http://www.xiaogou134.games/2021/05/16/MVC%E5%9C%A8swift%E9%87%8C%E6%80%8E%E4%B9%88%E7%94%A8/","excerpt":"","text":"MVC 基于经典的面向对象原则:对象在内部对它们的行为和状态进行管理，并通过类和协议的 接口进行通讯;view 对象通常是自包含且可重用的;model 对象独立于表现形式之外，且避免 依赖程序的其他部分。而将其他两部分组合起来成为完整的程序，则是 controller 层的责任。（自包含：组件不依赖其他组件，能够以独立的方式供外部使用。） Apple 将 MVC 描述为三种不同的子模式的集合: 合成模式 - view 被组装成为层级，该层级按组区分，由 controller 对象进行管理。 策略模式 - controller 对象负责协调 view 和 model，并且对可重用的、独立于 app 的 view 在 app 中的行为进行管理。 观察者模式 - 依赖于 model 数据的对象必须订阅和接收更新。 在view controller 上设置一个初始model值 通过判定 controller 在 controller 层级上的位置以及 controller 的类型，直接访问一个 全局的 model 对象。 开始时将 model 对象的引用设置为 nil 并让所有东西保持为空白状态，直到另一个 controller 提供了一个非 nil 值。 在 controller 初始化时将 model 对象当作参数传递进来 (也就是依赖注入)， 更改内部状态叫view stateview state的更新可以放在view或者view controller中 更改Model Table View 发送 Action View Controller 改变 Model View Controller 观察 Model 变更 View Controller 改变 View 在上面的步骤中，tableview没有直接改变Model，Mode也没办法直接改变tableview。他们交互通过KVO，而KVO在View Controller中实现 MVC模式的缺点观察者模式失效model 和 view 的同步可能失效，而Cocoa没办法确认是否失效 改进： 1.将 NoticationCenter 进行封装并为它实现 KVO 所包含的 初始化的概念。这个概念会在观察被建立的同时发送一个初始值，这允许我们将设定初始值和 观察后续值的操作合并到一个单一管道中去。 2.使用RxSwift 肥大的 View Controller非常大的 view controller 通常进行了它们的主要工作 (观察 model，展示 view，为它们提供数 据，以及接收 view action) 之外的无关工作; 进一步改进在扩展中进行代码重用要在不同的 view controller 间共享代码，一个常⻅的方法是创建一个包含共通功能的父类。这种方式还经常会导致我们常说的上帝view controller 的问题:一个共享的父类包括了项目中全部的共享的功能。这样的类通常会变 得非常复杂，难以维护。 改进：在多个 view controller 中都出现的方法有时候能够被添加到 UIViewController 的扩展中去。 123456789protocol ResizableContentView &#123;var resizableConstraint: NSLayoutConstraint &#123; get &#125;&#125;extension ResizableContentView where Self: UIViewController &#123; func addKeyboardObservers() &#123;// ...&#125; &#125;//利用协议为类提供额外的方法//对协议拓展为类提供额外的标准方法 利用 Child View Controller 进行代码重用将不同状态的view controller拆成不同的child view controller，会比一个view controller更好维护","raw":null,"content":null,"categories":[{"name":"swift","slug":"swift","permalink":"http://www.xiaogou134.games/categories/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://www.xiaogou134.games/tags/swift/"}]}]}